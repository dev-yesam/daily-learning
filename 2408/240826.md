# 2024-08-26

# 1초도 쉬지 않고 생각하기
-  JPA(기본->스부->데이터jpa) + B형 (평일)
-  CS + 취준 + GSAT (주말)


### 오늘 학습 내용
- JPA 공부
    - 프록시와 연관관계 관리


### 감사일기
73. 쾌적하게 공부할 수 있는 싸피 환경에 감사하다.
74. 서류 관련 응대해주신 공무원분께 감사하다.
75. 적극적으로 참여하는 프로젝트 팀원들에게 감사하다.
    

### 학습 내용 세부
- **프록시(Proxy) 객체**
    - DB 조회를 미루는 가짜(프록시) 엔티티 객체
    - 실제 엔티티 클래스를 상속 받아 만들어지고, 겉 모습이 똑같음
    - 실제 엔티티가 필요할 때까지 데이터 베이스 조회를 미룰 수 있음.
    
    ⇒ 지연 로딩(lazy loading) 전략을 구현하는 데 사용됨.
    
- **지연 로딩(lazy loading)**
    
    **⇒ 실무에서는 지연 로딩만 쓰기!!**
    
    - DB에서 실제 데이터를 즉시 로드하지 않고, 해당 객체의 데이터가 실제로 필요할 때까지 로딩을 미루는 것.
    - 그래서 참조하는 객체가 있을 때 걔는 프록시로 가져오게 되고, 프록시 객체가 실제로 필요할 때 DB에서 데이터 로드함.
        - ex) Member가 Team을 참조할 떄.
    
    **⇒ @ManyToOne, @OneToOne**의 기본 값이라 얘네들 꼭 바꿔줘야한다~
    
- **즉시 로딩(Eager Loading)**
    
    **⇒ 실무에서는 가급적 안쓰기.**.(예상못한 SQL 발생)
    
    ⇒  막 연관된 거 10개면 다 쿼리문 나가고….
    
    - DB에서 엔티티를 로드할 때, 해당 엔티티와 연관된 엔티티도 함께 즉시 로드하는 전략
    - 항상 함께 쓰는 엔티티들이라면, 쿼리문 두번 따로 보내는 거 보다, 즉시 로딩이 나음
- **fetch = FetchType.LAZY**
    - **@OneToMany,** @ManyToMany의 기본 값임
    - @ManyToOne, @OneToOne에서 괄호 열고 쓰면 됨.
- **fetch = FetchType.EAGER**
    - @ManyToOne, @OneToOne의 기본 값임
    - @OneToMany, @ManyToMany에서 괄호열고 쓰면 됨.
- **영속성 전이: CASCADE**
    - 특정 엔티티에 대한 작업이 다른 **연관된 엔티티에도** 전파되는 것
    - ex) 부모 엔티티 저장할 때 자식 엔티티도 저장한다든지. 삭제한다든지
- **CascadeType.xxx**
    - ALL
        - 부모 엔티티에 적용되는 모든 사항이 자녀 엔티티에도 적용
    - PERSIST
        - 부모 엔티티가 Persist(영속)될 때 자녀 엔티티도 영속됨
            - 결국 db에 같이 저장되게됨.
    
- **고아 객체 제거**
    - **orphanRemoval = true**
    - 부모 엔티티와 연관관계 끊어진 자식 엔티티 자동 삭제
    - 참조하는 곳이 하나일 때 사용
- **식별자**
    - 데이터를 고유하게 식별할 수 있는 모든 정보
- **Entity Type엔티티 타입**
    - **@Entity로 정의하는 객체**
    - DB에서 고유하게 식별될 수 있는 객체
    - 데이터가 변해도 식별자로 추적가능
- **Value Type 값 타입**
    - int, integer, String처럼 단순한 값으로 사용되는 **자바 기본 타입**이나 **객체**
    - 식별자 없이 단순 값만 있으니까 변경하면 추적 불가
    - **기본값 타입, 임베디드 타입, 컬렉션 값타입**으로 구분됨.
- **기본값 타입**
    - JPA에서 사용되는 **값타입 중 가장 단순한 형태**로, 자바에서 기본적으로 제공하는 데이터 타입
    - **종류**
        - 자바 기본 타입(int, double)
        - 래퍼 클래스(Integer, Long)
        - Stirng
- **임베디드 타입(복합값 타입)**
    - 여러 개의 기본값 타입들을 조합해서 만든 객체
    ⇒ 임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같음! 대신 깔끔하죠
    ⇒ 용어도 공통화 되고, 코드도 공통화되고, 공통 메서드 만들어서 쓸수도 있고 유용한듯?
    
- **임베디드 타입 사용법**
    - **@Embeddable** 값 타입을 정의하는 곳에 표시
        - 기본 생성자 필수
    - **@Embedded** 값 타입을 사용하는 곳에 표시
    - 둘 중 하나에만 애노테이션 넣으면 되는데, 둘 다 넣는 거 추천한댕
- **@AttributeOverride**
    - 한 엔티티에서 같은 값 타입 사용할 때, 칼럼 명이 중복되는 문제 생김
    - 이떄 override할 수 있음.
    - 한개면 AttributeOverride, 여러개면 AttributeOverrides

  
