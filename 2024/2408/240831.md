# 2024-08-31

# 1초도 쉬지 않고 생각하기
-  Spring + 프로젝트

### 오늘 학습 내용
- CS, 취준, 독서

### 할 일
- CS 공부
- 매일 암기



### 감사일기
101. 주말에 일찍부터 문을 열어주는 도서관에 감사하다.
102. 공기가 너무 상쾌해서 감사하다.
103. 숨을 쉴 수 있어서 감사하다.

    

### 학습 내용 세부
- **컴퓨터 구조에서 알아야 할 2가지 지식**
    - **1) 컴퓨터가** 이해하는 **정보** → 데이터, 명령어
    - **2) 컴퓨터의 4가지 핵심 부품**
- **컴퓨터가 이해하는 2가지 정보**
    - **데이터 Data**
        - 숫자, 문자, 동영상 등의 정적인 정보
        - 명령어의 재료
    - **명령어**
        - 데이터를 가지고 컴퓨터를 실제로 작동시키는 정보
- **메모리**
    - 현재 실행되는 프로그램의 명령어와 데이터를 저장하는 부품
        - 프로그램이 실행되려면 반드시 메모리에 저장되어있어야함.
    - 주소가 있어서 메모리 내  원하는 위치에 접근 가능
- **입출력 장치**
    - 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환할 수 있는 장치
- **버스 Bus**
    - 메인보드에 연결된 부품들이 정보를 주고 받을 수 있는 통로

**데이터**

- **워드(word)**
    - CPU가 한 번에 처리할 수 있는 데이터 크기
    - 현대 대부분의 컴퓨터는 워드 크기가 32비트나 64비트임.
        - 인텔의 x86 CPU는 32비트 워드 CPU, x64 CPU는 564비트 워드 CPU임
- **이진수의 음수 표현**
    - 2의 보수를 이용하는 게 가장 널리 사용됨
    - 어떤 수를 그보다 큰 2^n에서 뺀값
        - 쉽게 구하자면 0,1을 전부 바꾸고 1을 더하면 됨.
- **EUC-KR**
    - 한글 인코딩 방식의 하나(16비트로 표현)
    - 문자표에 없는 문자는 표현할 수 없었음. 웹사이트에서 글자가 깨진다거나 등 피해가 있었음
- **유니코드의 인코딩 방식**
    - 문자표에 있는 값을 그대로 인코딩 값으로 쓰던 아스키 코드와 다르게, 유니코드는 문자표에 있는 값을 범위에 따라 다르게 인코딩함.
        - 예를 들어 문자표 값이 0~10만까지는 1바이트로 표현하고, 10만~20만까지는 2바이트로 표현하고 등등.
    - 이렇게 인코딩 하는 방식이 UTF-8, 16, 32 등이 있음

**명령어**

- **소스 코드 Source code**
    - 컴퓨터 프로그램을 사람이 읽을 수 있는 프로그래밍 언어로 만든 텍스트 파일
    
    ⇒ 컴파일되게됨~
    
- **어셈블리어 assembly language**
    - 기계어를 사람이 읽기 조금 편하게 번역한 언어.
    - 하지만 똑같이 Low-level 언어임(저급언어)
- **어셈블리어를 알아야 하는 이유**
    - 하드웨어와 밀접하게 맞닿아 있는 프로그램을 개발하는 임베디드, 게임, 정보보안 개발자는 어셈블리어를 많이 관찰하고 작성하여 사용함
- **목적 코드 Object code**
    - 컴파일러를 통해 저급 언어로 변환된 코드
- **명령어의 구성 2가지**
    - **연산 코드(Operation code)**
        - 명령어가 수행할 연산
        - **연산자**라고도 부름
    - **오퍼랜드(Operand)**
        - **피연산자**라고도 부름
        - 연산에 사용될 데이터 또는 그 데이터가 저장된 위치**⇒ 0개일 수도, 여러개 일 수도 있음.**
            - 근데 보통 저장공간 떄문에 저장된 위치가 옴
            - 그래서 오퍼랜드 필드를 **주소 필드**라고도 부름
- **유효 주소 effective address**
    - **연산 코드**에 사용할 데이터가 저장된 위치
- **주소 지정 방식 addressing mode**
    - 명령어에서 데이터의 주소를 지정하는 방법
    - 대표적인 5가지 방식이 있음
- **즉시 주소 지정 방식 immediate addressing mode**
    
    
    - 걍 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 것
        - 딱히 주소 안 만들고 바로 데이터 때려박는 거인듯.
    - 표현할 수 있는 데이터 크기는 작음 but, 데이터를 메모리나 레지스터에서 찾을 필요가 없으므로 속도가 다른 방식 보다 빠름
- **직접 주소 지정 방식 direct addressing mode**
    
    
    - 오퍼랜드 필드에 유효 주소를 직접 명시하는 방식
    - 그래도 연산 코드 길이에 남는 자리 써야하니까, 유효주소 표현에도 제한있음
- **간접 주소 지정 방식 indirect addressing mode**
    
    
    - 오퍼랜드 필드에 유효 주소를 넣는게 아니라, 유효 주소의 주소를 넣음.
    - 그래서 표현할 수 있는 유효 주소 범위가 더 넓은 대신 속도는 다소 느림
- **레지스터 주소 지정 방식 register addressing mode**
    
    
    - 직접 주소 지정 방식과 유사하게 연산에 사용 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시
    - CPU 외부에 있는 메모리 접근 보다 CPU내부 레지스터 접근이 빠르기 때문에 속도는 빠름
    - 하지만 직접 주소 지정방식의 문제처럼 표현할 수 있는 레지스터 크기 제한있음
- **레지스터 간접 주소 지정 방식**
    
    
    - 연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효주소)를 저장한 레지스터를 오퍼랜드 필드에 명시
    - 메모리에는 1번 접근하니까 2번 접근하는 간접 주소 지정 방식보다는 빠름

**CPU**

- **CPU**
    
    **⇒ 명령어를 처리하는 장치**
    
- **CPU의 구성**
    - **ALU 산술논리연산장치 Arithmetic Logic Unit**
        - 연산 장치
    - **레지스터 register**
        - 작은 임시 저장 장치
    - **제어장치 CU : control unit**
        - **제어 신호를** 내보내고 **명령어를 해석**하는 장치
- **제어 신호**
    - **컴퓨터 부품**을 관리하고 작동시키는 전기 신호
- **ALU의 동작 과정**
    
    
    **(정보를 받아들일 때)**
    
    - 연산을 하기 위해 **레지스터**에서 **피연산자**를 받아들이고,
    - **제어 장치**로부터 **수행할 연산**을 알려주는 **제어 신호**를 받아들임
    - 그걸로 **연산**함
    
    **(정보를 내보낼 때)**
    
    - 연산의 **결과 값**을 메모리가 아닌 **레지스터**에 **일시**적으로 **저장**(메모리는 느려서)
    - **플래그**도 내보냄.
    
- **플래그 flag**
    - 연산 결과에 대한 추가 정보
        - 음수인지, 0인지 등..
- **플래그 레지스터**
    - 플래그 값들을 저장하는 레지스터
- **클럭 clock**
    
    
    - **컴퓨터의 모든 부품**이 **일사불란**하게 움직일 수 있게 하는 **시간 단위**
    - 컴퓨터의 모든 부품이 클럭신호에 맞춰 작동하게됨.
        
        ⇒ 이 주기에 맞게 레지스터에 데이터가 이동하거나 ALU 연산이 수행됨.
        
- **제어 장치의 핵심 역할**
    - 클럭, 현재 수행할 명령어, 플래그, 제어 신호를 받아 들임
    - CPU 내부와 외부로 제어 신호를 내보냄
- **명령어 사이클**
    
    - CPU가 명령어를 처리하는 정형화된 흐름
    - [1]메모리에서 명령어를 가져오는 **‘인출 사이클’**과
    - [2] 가져온 명령어를 실행하는 **‘실행 사이클’**이 반복됨
    - [3]근데, 명령어 인출했는데 메모리 접근이 더 필요한 경우도 있는데, 이를 **간접 사이클**이라함
    - [4] 인터럽트가 발생하면 인터럽트 서비스 루틴을 실행하고 다시 수행하던 작업으로 되돌아 옴
- **인터럽트interrupt**
    - CPU의 정상적인 작업을 방해하는 신호
    
- **동기 인터럽트**
    - CPU에 의해 발생하는 인터럽트
    - 프로그래밍 상의 오류와 같은 예외적인 상황에서 발생하는 인터럽트임
    
    ⇒ **예외Exception**라고 부름
    
- **비동기 인터럽트**
    - **주로 입출력 장치**에 의해 발생하는 인터럽트⇒ **하드웨어 인터럽트**라 부르겠다~
    - ex)프린터 작업 완료 알림이나, 키보드 타이핑 같은 입력 알림 등..
- **인터럽트 요청 신호**
    - CPU의 정상적인 실행 흐름을 끊기 전, CPU에게 인터럽트를 해도 되는지 요청신호를 보내는 것
- **인터럽트 플래그**
    - **플래그 레지스터**의 한 플래그로, 인터럽트를 받아들일지 무시할지 결정하는 플래그.
    - CPU가 처리하는 작업에 따라, 인터럽트 플래그가 가능인지 불가능인지 설정되어있음.
    - 근데, 불가능이라 되어있어도 막을 수 없는 인터럽트 (하드웨어 고장)등이 있음
- **인터럽트 서비스 루틴**
    
    
    - **인터럽트 핸들러** 라고도 부름
    - 인터럽트를 처리하기 위한 프로그램
- **인터럽트 벡터 interrupt vector**
    
    
    - 수많은 **인터럽트 서비스 루틴**을 **구분**하기 위한 정보(인터럽트 서비스 루틴의 시작 주소 포함)
        
        ⇒ 그래야 서비스 루틴의 시작주소를 알지.