# 2024-08-28

# 1초도 쉬지 않고 생각하기
-  Spring + 프로젝트

### 오늘 학습 내용
- JPA 학습
    => 이제 스프링 데이터 jpa로 가자


### 감사일기
79. 오늘도 살아서 하루를 보내서 감사하다.
80. 잘 수 있는 집이 있어서 감사하다.
81. 강하게 클 수 있는(?) 싸피 환경에 감사하다.
82. 운동을 한 나에게 감사하다.
83. 다시 또 다시 도전할 수 있음에 감사하다.
84. 에어컨이 있어서 감사하다.
85. 허리가 아프지 않아서 감사하다.
86. 소통에 적극적인 팀원들에게 감사하다.
87. 영수증 문제로 고생을 많이한 팀장에게 감사하다.

    

### 학습 내용 세부
- **페이징**
    - 페이지를 나눠서 데이터를 가져올 수 있도록 하는 것
- **setFirstResult( )와 setMaxResults()**
    
    - 페이징에서 조회 시작 위치
    - 조회할 데이터 수
    
- **JOIN 조인**
    - **두 개 이상의 테이블을 연결**하고, 그 테이블들 사이의 관계를 기반으로 데이터 결합하는 방법
    
- **INNER JOIN**
    - JOIN의 기본값
        - 두 테이블 연결할 때 가장 많이 사용함
    - 두 테이블에서 조인 조건에 일치하는 행만 반환 (양쪽 테이블에 모두 존재하는데이터만 가져옴)
- **LEFT JOIN (LEFT OUTER JOIN)**
    - 왼쪽 테이블의 모든 행을 반환하고, 조인 조건에 일치하는 오른쪽 테이블의 행을 가져옴.
    - 오른쪽 테이블에 일치하는 행이 없다면 NULL로 채워짐
- **RIGHT JOIN (RIGHT OUTER JOIN)**
    - 오른쪽 테이블의 모든 행을 반환하고, 조인 조건에 일치하는 왼쪽 테이블의 행을 가져옴
    - 왼쪽 테이블에 일치하는 행이 없다면 NULL로 채워짐
- **CROSS JOIN**
    - 막 조인이라고 함.
    - **그냥 두 테이블의 모든 조합을 각 행끼리 곱해서 반환함.**
        - 행 10개짜리  테이블과 행 4개짜리 테이블은 10 * 4 , 40행이 됨.
- **ON**
    - 조인할 때 조건을 지정하여, 조인할 때 조건 먼저 적용한 후 조인할 수 있음
    - WHERE는 조인 결과에 대해 조건을 지정하기 때문에 ON이 좀 더 효율적
- **서브 쿼리**
    - 쿼리 내부에 커리를 또 만드는 것
- **JPA 서브 쿼리의 한계**
    - WHERE, HAVING, SELECT(hibernate)
    - FROM 절의 서브 쿼리는 현재 JPQL에서 불가능
- **페치 조인(fetch Join)**
    - **연관된 엔티티**를 한번에 같이 조회하는 기능
    - SQL에서 제공하는 조인의 종류가 아니라, JPQL에서 성능 최적화를 위해 제공하는 기능
    
    ⇒ 일반 조인 실행 시 연관된 엔티티를 함께 조회하지 않음
    
- **DISTINCT**
    - SQL에서는 중복된 결과를 제거하는 명령
    - JPQL에서는 같은 식별자(pk같은거)를 가진 엔티티 중복 제거
    
- **Named 쿼리**
    - 미리 정의해두고 이름 부여해서 사용하는 쿼리
    - @NamedQuery를 엔티티에 위에 정의해서 쓰면 됨.
    
    ⇒ 로딩 시점에 JPA가 파싱해서 사용 (오류 잡아줄 수 있음)
    
    ⇒ 로딩 시점에 캐싱 돼서 코스트가 줄어듦
    
    ⇒ 나중에 스프링data jpa쓰면 깔끔하게 사용가능!
    
- **벌크 연산**
    - PK를 지정하지 않고 실행하는 update, delete문(변경 감지만으로 하기에 너무 많을 때…)
    - 영속성 컨텍스트를 무시하고 DB에 직접 쿼리를 날림(영속성 컨텍스트랑 꼬이지 않게 해야함...!!)
